# server.py 
import os
import json
from mcp.server.fastmcp import FastMCP
from fastapi import FastAPI
from contextlib import AsyncExitStack, asynccontextmanager
from tavily import TavilyClient

# Load env if needed
if os.getenv("RENDER") != "true":
    from dotenv import load_dotenv
    load_dotenv()

#mcp = FastMCP(name="TavilyServer", host="0.0.0.0", port=10000, stateless_http=True, lifespan=None)

# for HF Space
mcp = FastMCP(name="TavilyServer", host="0.0.0.0", port=7860, stateless_http=True, lifespan=None)

# Initialize Tavily
if "TAVILY_API_KEY" not in os.environ:
    raise Exception("TAVILY_API_KEY environment variable not set")
  
# Tavily API key
TAVILY_API_KEY = os.environ["TAVILY_API_KEY"]

# Initialize Tavily client
client = TavilyClient(TAVILY_API_KEY)

@mcp.tool()
def web_search(query: str) -> str:
    """
    Performs a web search using Tavily. 
    Returns a JSON string containing:
    - 'answer': A direct answer summary generated by the search engine.
    - 'results': A list of sources with title, url, and raw content.
    
    Use the 'answer' to understand the topic quickly, but rely on 'results' 
    to extract specific details and to provide accurate citations (URLs) in your final response.
    """

    try:
        # We include answer=True if we want Tavily to already give us a summary, 
        # but the important thing is to have the 'results' for provenance.
        res = client.search(
            query=query,
            max_results=5,
            include_answer=True, # This activates Tavily's "mini-LLM"
            search_depth="advanced"
        )
        
        # Build the data package for our Client Agent
        output = {
            "answer": res.get("answer", "No summary provided."),
            "query": query,
            "results": []
        }
        
        # Clean the results to avoid sending too much garbage to the client
        for r in res.get("results", []):
            output["results"].append({
                "title": r.get("title"),
                "url": r.get("url"),
                # Sometimes the content is very long, we can truncate it if we want to save tokens
                "content": r.get("content", "")[:2000] 
            })
        
        # Return a formatted JSON string. 
        return json.dumps(output, ensure_ascii=False)

    except Exception as e:
        return f"Error in the search: {str(e)}"

@asynccontextmanager
async def lifespan(app: FastAPI):
    async with AsyncExitStack() as stack:
        # Questo avvia il session_manager solo per il tool MCP
        await stack.enter_async_context(mcp.session_manager.run())
        yield

app = FastAPI(lifespan=lifespan)
app.mount("/tav", mcp.streamable_http_app())