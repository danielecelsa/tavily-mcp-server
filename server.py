# server.py 
import os
import json
from typing import Optional, Dict, Any, List
from mcp.server.fastmcp import FastMCP
from tavily import TavilyClient

# Load env if needed
if os.getenv("RENDER") != "true":
    from dotenv import load_dotenv
    load_dotenv()

PORT = int(os.environ.get("PORT", 8080))



# Initialize FastMCP
mcp = FastMCP(
    name="TavilyServer", 
    host="0.0.0.0", 
    port=PORT, 
    stateless_http=True
)

# Initialize Tavily
TAVILY_API_KEY = os.environ.get("TAVILY_API_KEY")
if not TAVILY_API_KEY:
    raise Exception("TAVILY_API_KEY missing")
client = TavilyClient(TAVILY_API_KEY)

@mcp.tool()
def web_search(query: str) -> str:
    """
    Performs a web search using Tavily. 
    Returns a JSON string containing:
    - 'answer': A direct answer summary generated by the search engine.
    - 'results': A list of sources with title, url, and raw content.
    
    Use the 'answer' to understand the topic quickly, but rely on 'results' 
    to extract specific details and to provide accurate citations (URLs) in your final response.
    """

    try:
        # We include answer=True if we want Tavily to already give us a summary, 
        # but the important thing is to have the 'results' for provenance.
        res = client.search(
            query=query,
            max_results=5,
            include_answer=True, # This activates Tavily's "mini-LLM"
            search_depth="advanced"
        )
        
        # Build the data package for our Client Agent
        output = {
            "answer": res.get("answer", "No summary provided."),
            "results": []
        }
        
        # Clean the results to avoid sending too much garbage to the client
        for r in res.get("results", []):
            output["results"].append({
                "title": r.get("title"),
                "url": r.get("url"),
                # Sometimes the content is very long, we can truncate it if we want to save tokens
                "content": r.get("content", "")[:2000] 
            })
        
        # Return a formatted JSON string. 
        return json.dumps(output, ensure_ascii=False)

    except Exception as e:
        return f"Error in the search: {str(e)}"

if __name__ == "__main__":
    mcp.run(transport="streamable-http")